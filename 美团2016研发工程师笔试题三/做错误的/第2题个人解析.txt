因为是线程不安全的，存在以下操作可能在两个线程内部彼此打乱：
①：读入内存中的a
②：进行++a操作。
++a的操作对应的汇编存在三条指令，也就是对应了三条机器指令，他们分别是：将a读入寄存器、对寄存器进行加一操作、将寄存器里面的值送回到内存。
③：进行printf("%d",a)操作，这个语句存在操作（个人猜测）包括将变量a压入输出栈（c语言的入栈应该也不是原子的）、将a进行出栈送给显示相关操作。

这里的打印应该都是向标准输出设备打印，也就是显示器打印，但是每一个入的栈不同，出栈打印的目标屏幕相同。所以这里的printf可以理解为两步：一是准备打印，也就是入栈。二是出栈打印，两个线程打印的目标地相同。

------------------------------------------------------------
下面对代码的可能情况进行分析：
int a = 1;
void foo(){
	++a;
	printf("%d",a);
}

以上代码存在两个线程执行，这里称这两个线程为线程1、线程2.

①：线程1读入a到寄存器，然后中断，线程2读入a到寄存器。然后线程1中进行a的自加跟回写到内存，然后进行线程2的自加跟回写内存，由于寄存器中之前都是读入一样的a=1，所以两次回写到内存的值是一样的都是2，这样打印之后的结果是 2 2
②：线程1读入a到寄存器，进行自加操作然后中断，线程2读入a，分析到这里这个情况跟上面的①的结果便是一样的了。
③：线程1读入a到寄存器，进行自加操作然后打印a，这时打印的a是2。然后线程2顺讯执行，打印结果3. 最后的结果是 2 3
④：线程1读入a自加并且回送到内存，中断。线程2读入a，这时a是2，进行自加跟回送内存，然后进行打印，然后线程1进行打印，这个结果是 3 3
⑤：线程1读入a自增后回送，线程1将a入栈，进行准备打印，然后中断。线程2读入a自增然后回送，线程2将a入栈然后出栈完成打印，结果是3。线程1接着执行出栈打印a，结果是2. 最终结果是 3 2.

note----对于⑤：这个是存在争议的一个点，2013年的阿里的实习题里面是不存在结果 3 2的情况的。个人分析原本也是更偏向于不存在这种情况，但是通过java代码的事实测试发现四种情况都是存在的。通过分析，如果把printf分成入栈准备跟出栈打印两步，这两步中间产生中断是有可能出现 3 2  这种情况的。