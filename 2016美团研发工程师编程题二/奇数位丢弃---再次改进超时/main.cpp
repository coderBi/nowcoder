/*
    其实通过分析可以得出最后剩余的假如是第 x 位，那么它一定是小于最大（第 n + 1位）位的最大的 2 的幂。
    这个结论可以通过下面进行推导：
        ①：第一次取出来位数： 2 4 6 8
        ②：第二次先把之前得到的位数除 2 得到： 1 2 3 4。然后留下来的是 2 4
        ③：每次都是这么操作，最后留下来的一定是一个 "1"。 它一定是 2 的幂。而且通过上面的流程可以发现它在最开始的数组中的位是最大的 2 的幂。
*/

/*
    最终通过测试发现，问题出现在下面代码的输入问题上，如果直接写 while(cin >> n) 就能正确得到结果。
    在本机测试发现二者没有区别，说明跟提交的服务器系统获取有关。
*/

#include <iostream>

using namespace std;


int main()
{
    int n;
    while(cin.peek() != -1){
        cin >> n;
        cout << "n: " << n << endl;
        int result = 1;
        while(result <= n + 1){
            result *= 2;
        }
        result /= 2; //上面的循环多移了一位。
        cout << result -1 << endl;  //第 x 位的数字是 x -1;
        //cin.sync(); //清空输入缓存，避免下次输入收到干扰
    }
    return 0;
}
